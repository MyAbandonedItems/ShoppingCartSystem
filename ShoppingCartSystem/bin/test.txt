step1：hello - LoginFrame check identify 
step2：JTree 的使用-加上监听
http://www.cnblogs.com/huqingyu/archive/2008/04/09/1145894.html
Step3：JTable 的使用-滚动条
http://www.cnblogs.com/lixiaolun/archive/2012/12/19/2825080.html

Debug log
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	尝试过的一种填充数据的方法
	
		/*Object[][] cellData = {//默认设置29个元组数据
				{"商品名称", "商品序列号","价格", "总数", "剩余"},
				{Gname.elementAt(1), GID.elementAt(1),Gprice.elementAt(1),Gamount.elementAt(1),Gremain.elementAt(1)},
				/*{},{},{},{},{},{},{},{},{},{},
				{},{},{},{},{},{},{},{},{},{},
				{},{},{},{},{},{},{},{},{},{}//28 tuples
				{" ", " "," ", " ", " "}
		};*/
		/*for (int i = 2; i < 30; i++) {
			cellData[i][0]="1";
			System.out.println(i);
		}*/
		/*String[] columnNames = {"col1", "col2","col1", "col2", "col2"};
		
		JTable table = new JTable(cellData, columnNames);*/

给JTable加上滚动条的时候废了好久，原来加了滚动条，滚动条必须设置位置和尺寸才行
当时我是这样写的, this.add(new JScrollPane(table));//显然是不行的，实现的效果是table不可见
////////////////////////////////////////////////////////////////////////////////////////////////////////////

Debug Log
由于设计需求，需要将单选按钮的监听和输入框的监听分开，
因为在LoginFrame中new出来的usrMode 必须传到InfoCheck的实现类中进行选择验证的表，
而InfoCheck的实现类必须获取输入框中的数据，这之间一定得要有一个先后的过程，显然必须先 new出usrMode对象
否则需要在监听类中写太多的代码，这违背了松耦合的原则
也正因此，当我这么做的时候，新的问题有出现了，
当用户还没有点击单选按钮的时候，usrmode对象，已经传过来来，这显然与实际不符，所以测试时监听不起作用
解决方案：

////////////////////////////////////////////////////////////////////////////////////////////////////////////

在写这个RegisterPageListener类的时候，按照自己的理解，
在类内的第一行就直接写了 RegisterPage rl = new RegisterPage();
这行代码的意思就是只要加上监听，就重新在内存中为RegisterPage开辟一个内存，而开辟的这个内存又会重新添加监听，
如此就形成了死循环，在内存中不停的开辟空间，导致我的电脑轰轰得响，而且还不显示界面，最终被我发现了这个BUG，
不能开辟内存，只是简单的定义一个变量接受传过来的对象，开辟内存的意思就是再重新造一个对象，既然要接受穿过来的对象，
再造一个对象明显就是错误的写法，对内存理解不深刻，按照惯例来写就可能产生很多莫名其妙的BUG
